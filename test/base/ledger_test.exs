defmodule Wumpex.Base.LedgerTest do
  @moduledoc false
  use ExUnit.Case, async: false
  alias Wumpex.Base.Ledger

  @test_key "wumpex-test-ledger-test-process"
  @test_metadata %{"hello" => "world"}

  setup_all do
    Application.ensure_started(:syn)

    on_exit(fn ->
      Application.stop(:syn)
    end)
  end

  setup do
    {:ok, registry} = Registry.start_link(name: __MODULE__.LocalRegistry, keys: :unique)
    Registry.register(__MODULE__.LocalRegistry, @test_key, @test_metadata)
    :syn.register(@test_key, self(), @test_metadata)

    {:ok,
     %{
       registry: registry,
       pid: self()
     }}
  end

  describe "The child_spec generated by __using__ should" do
    test "generate a call to start_link in distributed mode" do
      assert %{
               id: __MODULE__.GlobalRegistry,
               start: {__MODULE__.GlobalRegistry, :start_link, []}
             } = __MODULE__.GlobalRegistry.child_spec()
    end

    test "generate a call for Registry in local mode" do
      expected =
        Registry.child_spec(
          name: __MODULE__.LocalRegistry,
          keys: :unique,
          partitions: System.schedulers_online()
        )

      assert ^expected = __MODULE__.LocalRegistry.child_spec()
    end
  end

  describe "The start_link method generated by __using__ should" do
    test "return :ignore in distributed mode" do
      assert :ignore = __MODULE__.GlobalRegistry.start_link()
    end

    test "return call Registry.start_link/1 in local mode" do
      # Setup already starts the LocalRegistry, so this should return already started.
      assert {:error, {:already_started, _pid}} = __MODULE__.LocalRegistry.start_link()
    end
  end

  describe "The lookup/1 method generated by __using__ should take a name and return PID/metadata or nil" do
    test "in local mode", %{pid: pid} do
      assert {^pid, @test_metadata} = __MODULE__.LocalRegistry.lookup(@test_key)
      assert nil == __MODULE__.LocalRegistry.lookup("does-not-exist")
    end

    test "in distributed mode" do
      pid = self()
      assert {^pid, @test_metadata} = __MODULE__.GlobalRegistry.lookup(@test_key)
      assert nil == __MODULE__.GlobalRegistry.lookup("does-not-exist")
    end
  end

  describe "The register/3 method generated by __using__ should take a name, pid and optionally metadata and return :yes or :no" do
    test "in local mode", %{pid: pid} do
      assert :yes = __MODULE__.LocalRegistry.register("my-name", pid, @test_metadata)
      assert {^pid, @test_metadata} = __MODULE__.LocalRegistry.lookup("my-name")
    end

    test "in distributed mode", %{pid: pid} do
      assert :yes = __MODULE__.GlobalRegistry.register("my-name", pid, @test_metadata)
      assert {^pid, @test_metadata} = __MODULE__.GlobalRegistry.lookup("my-name")
    end
  end

  describe ":via support should work" do
    test "in local mode without metadata" do
      name = {:via, __MODULE__.LocalRegistry, "via-without-metadata"}
      {:ok, pid} = GenServer.start_link(__MODULE__.EchoModule, [], name: name)

      assert {^pid, _meta} = __MODULE__.LocalRegistry.lookup("via-without-metadata")
      assert :pong = GenServer.call(name, :ping)
    end

    test "in local mode with metadata" do
      name = {:via, __MODULE__.LocalRegistry, {"via-with-metadata", @test_metadata}}
      {:ok, pid} = GenServer.start_link(__MODULE__.EchoModule, [], name: name)

      assert {^pid, @test_metadata} = __MODULE__.LocalRegistry.lookup("via-with-metadata")
      assert :pong = GenServer.call(name, :ping)
    end

    test "in distributed mode without metadata" do
      name = {:via, __MODULE__.GlobalRegistry, "via-without-metadata"}
      {:ok, pid} = GenServer.start_link(__MODULE__.EchoModule, [], name: name)

      assert {^pid, _meta} = __MODULE__.GlobalRegistry.lookup("via-without-metadata")
      assert :pong = GenServer.call(name, :ping)
    end

    test "in distributed mode with metadata" do
      name = {:via, __MODULE__.GlobalRegistry, {"via-with-metadata", @test_metadata}}
      {:ok, pid} = GenServer.start_link(__MODULE__.EchoModule, [], name: name)

      assert {^pid, @test_metadata} = __MODULE__.GlobalRegistry.lookup("via-with-metadata")
      assert :pong = GenServer.call(name, :ping)
    end
  end

  defmodule LocalRegistry do
    @moduledoc false
    use Ledger, global: false
  end

  defmodule GlobalRegistry do
    @moduledoc false
    use Ledger, global: true
  end

  defmodule EchoModule do
    @moduledoc false
    use GenServer

    @impl GenServer
    def init(_options) do
      {:ok, %{}}
    end

    @impl GenServer
    def handle_call(:ping, _from, state) do
      {:reply, :pong, state}
    end
  end
end
